# Overview
This project serves as the abstract syntax tree for `scratch-code`. It is able to represent basic structures of imperative programming languages, mainly focused on C.

# Components
`scratch-code-ast` makes heavy use of object-orientation. This makes it possible to generalize instances easily. To specialize them again, while avoiding [object slicing](https://en.wikipedia.org/wiki/Object_slicing), the project uses `std::shared_ptr` in almost every case. This also has the advantage that objects, which often need to be referenced multiple times, do not need to be copied expensively.

## Inheritance graph
When you look at the file `include/AST.hpp`, you can see the class hierarchy of `scratch-code-ast`. In the following, there is a inheritance graph kindly generated by [Doxygen](http://www.stack.nl/~dimitri/doxygen/) and [Graphviz DOT](http://www.graphviz.org/).

![inheritance graph](https://github.com/sigalor/scratch-code-ast/raw/master/info/inherit_graph.png)

## Class descriptions
As you can see, the `Node` class is the ancestor of all other classes. Descriptions all of the classes are:

Class name | Description
---------- | -----------
**Node** | is the ancestor of all other classes and contains the parent and id
&nbsp;&nbsp;&nbsp;&nbsp;**Statement** | bundles class instances which are able to appear in the parsed source code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**VariableDefinition** | defines a variable, consisting of a type and a name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**FunctionDefinition** | defines a function, consisting of a return type, name, argument names and types and statement list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Value** | bundles class instances which can be used as a single value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**LValue** | means _locatable value_, i.e. references a `VariableDefinition` which has a specific and user-defined point in memory
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**RValue** | is the opposite of `LValue`, i.e. you do not really know where this value is actually stored
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**RValueValue** | represents a simple literal, either bool (`true` or `false`), number (e.g. `42` or `3.14159`) or string (e.g. `Example string`)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**FunctionCall** | represents calling a function previously defined by `FunctionDefinition`, is an `RValue`, as a returned value has this property
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Operation** | bundles unary and binary operations
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**UnaryOperation** | combines a `Value` with an unary operator (see below)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**BinaryOperation** | combines two instances of `Value`, left hand side and right hand side, with a binary operator (see below)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**ControlFlowStatement** | bundles statements which are able to change the flow of execution, i.e. make it possible for it to have multiple paths
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Conditional** | represents _if [else if]* [else]?_ statements, i.e. conditional objects which consist of multiple conditions (_if_ and _else if_) and a final alternative (_else_).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**ControllableLoop** | bundles loops which are controllable by a `LoopControlStatement`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**ForLoop** | a classic _for_ loop, consisting of an initialization, condition, afterthought and statements
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**WhileLoop** | a classic _while_ loop, consisting of a condition and statements
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**LoopControlStatement** | controls a `ControllableLoop`, e.g. with `break` or `continue`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**ReturnStatement** | belongs to a `FunctionDefintion` and makes this function return the specified value, or nothing for void
&nbsp;&nbsp;&nbsp;&nbsp;**StatementList** | is essentially just an array of `Statement`, used to integrate it better into the `ast` namespace
&nbsp;&nbsp;&nbsp;&nbsp;**VariableDefinitionList** | an array of `VariableDefinition`
&nbsp;&nbsp;&nbsp;&nbsp;**ValueList** | an array of `Value`

## Variable types
In the strongly-typed enumeration `ParsedVariableType` in `include/LexerTokenDefinitions.hpp`, there are multiple variable types defined. `scratch-code-ast` has very strict typing, so these are the only types available.

Type name | Default value | Description
--------- | ------------- | -----------
**void** | *(none)* | can only be used for function return types, not for variables. Indicates that the function returns no value
**bool** | `false` | a Boolean value, i.e. has only two states: `true` or `false`
**int** | `0` | an integer, which has no specific value range and may be positive or negative
**real** | `0.0` | a real value, i.e. a floating point value
**string** | `""` | a list of characters which forms a text

## Other concepts

### LValues and RValues: Value categories
`scratch-code-ast` relies on the concept of lvalues and rvalues. Every `ast::Value` results in one of these types, which are called *value categories* in the code. The difference between these two value categories may be hard to grasp at the beginning, but you will soon notice the necessity of this concept.

In general, you can imagine lvalues as values that have a name. When you define a variable and call it by its name later in your code, you get an lvalue. This was already mentioned in the short `ast::LValue` class description above.

On the other hand, an rvalue is a temporary value. It cannot be accessed again after its statement is finished.

For another explanation, look at a simple assignment like `a = 42;` (of course `a` has been defined before). Here, `a` is an lvalue which references the previously defined variable `a`. Thus, you can assign something to it, in this case `42`. Next, look at the incorrect statement `a+3 = 123;`. This makes no sense, as the left hand side of the assignment operator is now an rvalue, because `a+3` is just temporary. Thus, you can only assign to lvalues. That's why this concept is essential for `scratch-code-ast`.

## Operations

There are some things to say about different kinds of operations.

- First of all, the logical ones: `LogicalNot`, `LogicalAnd` and `LogicalOr`. When you apply these to a value, this value is always implicitly casted to `bool` beforehand, i.e. `if(!a)` means `if(!((bool)a))`. As you can see in the *Allowed input types* for unary operations below, a typecast to bool is possible for all types that have a value.
- Next, comparison operators (`LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual`, `Equal`, `NotEqual`) are evaluated by implicitly casting the values to `int`, except that `real` is kept as it is.
- The binary `Add` operator is not only applicable to numeric types (i.e. `int` and `real`, but also to `string`. In this case, it means string concatenation.
- The difference between the prefix and postfix increment and decrement operators is rather hard to get, but if you would really like to understand it, look at [this](http://stackoverflow.com/a/7031409/3554605) Stack Overflow answer (it is not by me though).

### Unary operations
Another strongly-types enumeration in `include/LexerTokenDefinitions.hpp` is `ParsedUnaryOperation`. It contains the operation used for the `ast::UnaryOperation` class. They all have almost the same meaning in C, making a separate explanation not necessary. The *input value category* and *output value category* column contents were extracted from the functions `getRequiredValueCategory` and `getResultingValueCategory` defined in `src/LexerTokenDefinitions.hpp`. The position is given relative to the input value, e.g. for a LogicalNot, `~a` is correct, while `a~` is not.

Name | Symbol | Position | Allowed input types | Input value category | Output value category
---- | --------- | -------------------- | ---------------------
LogicalNot | `!` | before | bool, int, real, string | any | rvalue
BitwiseNot | `~` | before | bool, int | any | rvalue
PrefixIncrement | `++` | before | int, real | lvalue | lvalue
PrefixDecrement | `--` | before | int, real | lvalue | lvalue
PostfixIncrement | `++` | after | int, real | lvalue | rvalue
PostfixDecrement | `--` | after | int, real | lvalue | rvalue
UnaryPlus | `+` | before | int, real | any | rvalue
UnaryMinus | `-` | before | int, real | any | rvalue
TypecastBool | `(bool)` | before | bool, int, real, string | any | rvalue
TypecastInt | `(int)` | before | bool, int, real, string | any | rvalue
TypecastReal | `(real)` | before | bool, int, real, string | any | rvalue
TypecastString | `(string)` | before | bool, int, real, string | any | rvalue

### Binary operations
Similarly to unary operations, binary operations are defined in the strongly-typed enumeration `ParsedBinaryOperation` in  `include/LexerTokenDefinitions.hpp` as well. They are used for the `ast::BinaryOperation` class. Again, there is no difference to C. The value category information also comes from the same file. Note that, for an `ast::BinaryOperation`, the types of both values need to be the same. If they are not, that's what typecasts are for.

Name | Symbol | Left hand side input value category | Right hand side input value category | Output value category






